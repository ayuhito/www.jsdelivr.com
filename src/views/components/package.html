<link rel="ractive" href="./collection-box.html" name="c-collection-box">
<link rel="ractive" href="./package-file-browser.html" name="c-package-file-browser">
<link rel="ractive" href="./package-header.html" name="c-package-header">
<link rel="ractive" href="./top-stats-table.html" name="c-top-stats-table">
<link rel="ractive" href="./package-sidemenu.html" name="c-package-sidemenu">
<link rel="ractive" href="./markdown.html" name="c-markdown">

<div class="c-package">
	<div class="container">
		{{#if versions}}
			<div class="row">
				<div class="main-content">
					<c-package-header
						package="{{package}}"
						type="{{type}}"
						name="{{name}}"
						version="{{versionP}}"
						packageVersionsNotFound="{{packageVersionsNotFound}}"
						navRoute="{{navRoute}}">
					</c-package-header>

					<div class="package-nav">
						{{#if package.readme && package.readme !== algoliaReadmeErrMsg}}
							<a id="navRouteReadme" on-click="@this.set('navRoute', 'readme')" class="package-nav-route {{navRoute === 'readme' ? 'package-nav-route-active' : ''}}">
								<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/book.svg"><span>Readme</span>
							</a>
						{{/if}}
						<a id="navRouteConfig" on-click="@this.set('navRoute', 'config')" class="package-nav-route {{navRoute === 'config' ? 'package-nav-route-active' : ''}}">
							<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/settings.svg"><span>Show/Configure Files</span>
						</a>
						<a id="navRouteStats" on-click="@this.set('navRoute', 'stats')" class="package-nav-route {{navRoute === 'stats' ? 'package-nav-route-active' : ''}}">
							<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/statistics.svg"><span>Statistics</span>
						</a>
						<a target="_blank" rel="noopener noreferrer" href="https://cdn.jsdelivr.net/npm/{{name}}/" class="package-nav-route">
							<span>Browse CDN Files</span><img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/external-link.svg">
						</a>
					</div>

					{{#if navRoute === 'readme' && package.readme !== algoliaReadmeErrMsg}}
						<div class="package-readme">
							<c-markdown text="{{package.readme}}"></c-markdown>
						</div>
					{{/if}}
				</div>

				<div class="side-content">
					<c-package-sidemenu
						navRoute="{{navRoute}}"
						name="{{name}}"
						type="{{type}}"
						package="{{package}}">
					</c-package-sidemenu>
				</div>

				<div style="display: {{#if navRoute === 'config'}}flex{{else}}none{{/if}};" class="package-config full-width-content">
					<c-package-file-browser
						type="{{type}}"
						name="{{name}}"
						github="{{package.githubRepo}}"
						version="{{versionP}}"
						versions="{{versions}}"
						path="{{path}}"
						collection="{{collection}}"
						files="{{~/files}}">
					</c-package-file-browser>

					<c-collection-box collection="{{collection}}"></c-collection-box>
				</div>

				<div style="display: {{#if navRoute === 'stats'}}block{{else}}none{{/if}};" class="package-statistics full-width-content">
					<div class="header">
						<div class="header-title">Statistics</div>
						<div class="header-ctrls">
							<div class="chart-type-ctrl">
								<span>Show numbers of</span>

								<input id="chart-switch"
									type="checkbox"
									class="chart-type-switch {{#if showChartBandwidth}}checked{{/if}}"
									twoway="false">

								<label for="chart-switch" on-click="@this.set('showChartBandwidth', !showChartBandwidth)">
									<span>Request</span>
									<span>GB</span>
								</label>
							</div>

							<div class="data-range-ctrl">
								<span>Data range:</span>

								<div class="btn-group">
									<button type="button" class="btn dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
										<span>{{~/statsPeriods[statsPeriod]}}</span>
										<i class="fa fa-angle-down" aria-hidden="true"></i>
									</button>

									<ul class="dropdown-menu">
										{{#each ~/statsPeriods}}
											<li><a on-click="@this.set('statsPeriod', @key)">{{this}}</a></li>
										{{/each}}
									</ul>
								</div>
							</div>
						</div>
					</div>

					<div class="stats-cards">
						<div>
							<div class="card-icon">
								<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/request.svg">
							</div>
							<div class="card-main-stat">
								<span>{{_.formatNumber(versionsHitsTotal)}}</span>
								<span>Requests Served</span>
							</div>
							<div class="card-growth">
								<span class="growth-positive">+34%</span>
								<span>monthly growth</span>
							</div>
						</div>

						<div>
							<div class="card-icon">
								<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/transfer.svg">
							</div>
							<div class="card-main-stat">
								<span>648 414</span>
								<span>Bandwidth</span>
							</div>
							<div class="card-growth">
								<span class="growth-negative">-9%</span>
								<span>monthly growth</span>
							</div>
						</div>
					</div>

					{{#if noPackageStatsData && noVersionsData}}
						<div class="no-data-wrapper">
							<img width="180" height="152" src="{{@shared.assetsHost}}/img/no-data-chart-main.svg">
							<span>No statistics yet</span>
							<span>This is probably not a very popular package :(</span>
						</div>
					{{else}}
						<div class="chart-stats-per-period">
							{{#if statsDateData.total}}
								<div class="package-usage">
									<div class="small-headline">Stats for last {{~/statsPeriods[statsPeriod]}}</div>

									<div class="group-by-ctrl">
										<span>
											Group by:
										</span>

										<div class="btn-group">
											<button type="button" class="btn dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
												<span>{{~/usageChartGroupByValues[usageChartGroupBy]}}</span>
												<i class="fa fa-angle-down" aria-hidden="true"></i>
											</button>

											<ul class="dropdown-menu">
												{{#each ~/usageChartGroupByValues}}
													<li><a on-click="@this.set('usageChartGroupBy', @key)">{{this}}</a></li>
												{{/each}}
											</ul>
										</div>
									</div>
								</div>

								<div class="stats-chart-wrapper">
									<canvas id="stats-chart"></canvas>
								</div>
							{{/if}}
						</div>

						<div class="horizontal-divider mt-40 mb-40"></div>

						<div class="chart-tops">
							{{#if ~/topFiveVersions}}
								<c-top-stats-table title="Top 5 versions" data="{{~/topFiveVersions}}" type="{{~/type}}" name="{{~/name}}" version="{{~/fileStatsVersion}}">
									{{#partial column1}}
										<a on-click="@this.set('version', version)">{{version}}</a>
									{{/partial}}
								</c-top-stats-table>

								<c-top-stats-table data="{{~/fileStats ? ~/fileStats.slice(0, 5): []}}"
									type="{{~/type}}"
									name="{{~/name}}"
									version="{{~/fileStatsVersion}}"
									versions="{{~/versions}}">
									{{#partial header}}
										Top 5 files in version
										<c-version-dropdown versions="{{versions}}" version="{{version}}"></c-version-dropdown>
									{{/partial}}

									{{#partial column1}}
										<a title="{{file}}" target="_blank" rel="noopener noreferrer" href="https://cdn.jsdelivr.net/{{~/type}}/{{~/name}}@{{~/version}}{{file}}">{{file}}</a>
									{{/partial}}
								</c-top-stats-table>
							{{/if}}
						</div>

						<div class="horizontal-divider mt-40 mb-40"></div>

						<div class="chart-hits-per-period">
							{{#if versionsHitsTotal}}
								<div class="package-usage">
									<div class="small-headline">Hits per {{~/statsPeriods[statsPeriod]}} per version</div>
								</div>

								<div class="hits-chart-wrapper">
									<canvas id="hits-chart"></canvas>
								</div>

								<div class="hits-chart-legend">
									{{#each topFiveVersions}}
										<div class="legend-item">
											<div></div>
											{{version}}
										</div>
									{{/each}}
								</div>
							{{/if}}
						</div>
					{{/if}}
				</div>
			</div>
		{{/if}}
	</div>
</div>

<script>
	const _ = require('../../public/js/_');
	const http = require('../../public/js/utils/http');
	const debounce = require('../../public/js/utils/debounce');
	const clipboard = require('../../public/js/decorators/clipboard');
	const tooltip = require('../../public/js/decorators/tooltip');

	component.exports = {
		computed: {
			// TODO: add resizing to both stats and hits charts
			// chartXInterval () {
			// 	this.get('_resizeId'); // Keep this here so that it updates on resize.
			// 	return this.get('bottomChartLabels') ? Math.ceil(this.get('bottomChartLabels').length / Math.floor(innerWidth / 140)) : 1;
			// },
			hasSourceMaps () {
				let files = this.get('files');
				let hasMin, hasMap;

				if (!files) {
					return true;
				}

				_.flattenFiles(files).forEach((file) => {
					if (/\.min\.(?:js|css)$/.test(file)) {
						hasMin = true;
					} else if (/\.map$/.test(file)) {
						hasMap = true;
					}
				});

				return !hasMin || hasMap;
			},
			issueSourceMaps () {
				return `https://github.com/${this.get('package.githubRepo.user')}/${this.get('package.githubRepo.project')}/issues/new/`
					+ `?title=No source maps for minified files`
					+ `&body=[This package](${this.get('@global.location.href')}) doesn't contain source maps for the minified files. It would be great to add them for easier debugging.`;
			},
		},
		data () {
			return {
				_,
				collection: [],
				statsPeriods: {
					1: 'day',
					7: 'week',
					30: 'month',
					365: 'year',
				},
				statsPeriod: 30,
				versions: [],
				link: location.href,
				_resizeId: 0,
				navRoute: 'readme',
				showChartBandwidth: false,
				usageChartGroupByValues: {
					day: 'day',
					week: 'week',
					month: 'month',
				},
				usageChartGroupBy: 'day',
				algoliaReadmeErrMsg: 'ERROR: No README data found!',
				noPackageStatsData: false,
				noVersionsData: false,
				versionsHitsTotal: 0,
			};
		},
		decorators: {
			clipboard,
			tooltip,
		},
		oninit () {
			if (!Ractive.isServer) {
				let statsChart;
				let hitsChart;

				// Load package versions.
				http.fetchPackageVersions(this.get('type'), this.get('name')).then((data) => {
					this.set('versions', data.versions);

					// This can only happen for GitHub packages.
					if (data.versions.length === 0) {
						return this.set({ packageVersionsNotFound: true });
					}

					// Set version for GitHub packages.
					if (!this.get('package.version')) {
						this.set('package.version', data.versions[0]);
					}

					// Set version for GitHub packages or when an invalid version is selected.
					if (!this.get('versionP') || data.versions.indexOf(this.get('versionP')) === -1) {
						this.set('versionP', data.versions[0]);
					}
				}).catch((error) => {
					this.set({ packageNotFound: true });
					console.error(`Package versions not found.`, error);
				});

				this.observe('statsPeriod fileStatsVersion', () => {
					if (this.get('statsPeriod') && this.get('fileStatsVersion')) {
						let type = this.get('type');
						let name = this.get('name');
						let version = this.get('fileStatsVersion');
						let period = this.get('statsPeriods')[this.get('statsPeriod')];

						Pace.restart();

						http.fetchPackageFileStats(type, name, version, period).then((data) => {
							let array = [];

							Object.keys(data.files).forEach((key) => {
								array.push({
									file: key,
									hits: data.files[key].total,
								});
							});

							this.animate('fileStats', array.sort((a, b) => b.hits - a.hits));
						});
					}
				});

				this.observe('statsPeriod versionP navRoute', () => {
					if (this.get('statsPeriod') && this.get('versionP')) {
						let type = this.get('type');
						let name = this.get('name');
						let period = this.get('statsPeriods')[this.get('statsPeriod')];

						// get package date stats data and create stats chart
						http.fetchPackageDateStats(type, name, period).then((response) => {
							if (!response.total) {
								this.set('noPackageStatsData', true);
								return;
							}

							let array = [];
							this.set('statsDateData', response);

							Object.keys(response.dates).forEach((date) => {
								array.push([ date, response.dates[date] ]);
							});

							array.sort((a, b) => new Date(a[0]) - new Date(b[0]));

							if (statsChart) {
								statsChart.destroy();
								statsChart = null;
							}

							// create chart data, labels etc.
							let xAxisDates = array.map(value => value[0]);
							let data = array.map(value => value[1].total);

							let chartEl = this.find('#stats-chart');

							// create bar with background with gradient
							let createBarWithGradient = (chart) => {
								let barBackground = chart.getContext('2d').createLinearGradient(0, 0, 0, 300);
								barBackground.addColorStop(0, 'rgb(246, 81, 40)');
								barBackground.addColorStop(1, 'rgba(246, 81, 40, 0.08)');

								return barBackground;
							};

							// get period for chart representation
							let chartPeriod = this.get('statsPeriods')[this.get('statsPeriod')];

							// get range of y-axis
							let maxValue = Math.max(...data);
							let magnitude = Math.floor(Math.log10(maxValue));
							let statsChartYMax = Math.ceil(maxValue / Math.pow(10, magnitude)) * Math.pow(10, magnitude);
							let yAxisTicksAmount = 8;
							let yAxisRange = _.linRange(statsChartYMax, yAxisTicksAmount).reverse();

							// create vertical y-axis border line
							let verticalYAxisBorder = {
								id: 'statsChartYBorder',
								beforeDraw (chart) {
									let { ctx } = chart;
									ctx.save();
									ctx.beginPath();
									ctx.moveTo(89, 0);
									ctx.lineTo(89, 290);
									ctx.lineWidth = 1;
									ctx.strokeStyle = '#DADDE2';
									ctx.stroke();
									ctx.restore();
								},
							};

							// handle hover over the chart to change colors of the bars
							let createChartHoverHandler = (event, elements, chart) => {
								if (elements.length !== 1) { return; }

								event.native.target.style.cursor = 'pointer';
								chart.config._config.options.elements.bar.backgroundColor = '#FAE5E0';
								chart.update();
							};

							// handle mouse out of the chart area to restore bar colors
							let createChartMouseOutHandler = {
								id: 'chartMouseOutHandler',
								afterEvent (chart, args) {
									let { event } = args;

									if (event.type === 'mouseout') {
										event.native.target.style.cursor = 'default';
										chart.config._config.options.elements.bar.backgroundColor = createBarWithGradient(chartEl);
										chart.update();
									}
								},
							};

							// statsChart configuration
							let statsChartConfig = {
								type: 'bar',
								data: {
									labels: _.getChartXAxisData(xAxisDates, chartPeriod),
									datasets: [{
										data,
										borderWidth: 0,
										barThickness: chartPeriod === 'year' ? 2 : 10,
										hoverBackgroundColor: '#F65128',
									}],
								},
								options: {
									responsive: true,
									maintainAspectRatio: false,
									elements: {
										bar: {
											backgroundColor: createBarWithGradient(chartEl),
										},
									},
									plugins: {
										legend: {
											display: false,
										},
										tooltip: {
											enable: true,
											bodyColor: '#fff',
											backgroundColor: 'rgba(17, 26, 44, .9)',
											cornerRadius: 4,
											padding: 6,
											caretSize: 0,
											caretPadding: 8,
											bodyAlign: 'center',
											displayColors: false,
											xAlign: 'center',
											yAlign: 'bottom',
											bodyFont: {
												size: 12,
												weight: 600,
												family: 'Lexend, sans-serif',
												style: 'normal',
												lineHeight: 1.3,
											},
											callbacks: {
												title: () => {},
												footer: () => {},
												label: (ctx) => {
													let { formattedValue } = ctx;
													// TODO: for future use, to return measurement units e.g.
													// return `${formattedValue} GB`;
													return formattedValue;
												},
											},
										},
									},
									scales: {
										x: {
											display: true,
											ticks: {
												color: '#5C667A',
												font: {
													size: 12,
													family: 'Lexend, sans-serif',
													lineHeight: 2,
												},
												callback (tickIdx) {
													let labelValue = this.getLabelForValue(tickIdx);
													let day = Array.isArray(labelValue) ? labelValue[0].split('-').slice(-1)[0] : labelValue.split('-').slice(-1)[0];

													if (chartPeriod === 'year') {
														if (tickIdx !== 0 && tickIdx % 30 === 0) {
															return [ labelValue[1] ];
														}

														return;
													}

													if (Array.isArray(labelValue)) {
														return [ day, labelValue[1] ];
													}

													return [ day ];
												},
											},
											grid: {
												display: false,
												drawBorder: false,
											},
										},
										y: {
											display: true,
											min: yAxisRange[yAxisTicksAmount - 1],
											max: yAxisRange[0],
											ticks: {
												stepSize: yAxisRange[yAxisTicksAmount - 1],
												count: yAxisTicksAmount,
												color: '#5C667A',
												crossAlign: 'far',
												font: {
													size: 12,
													family: 'Lexend, sans-serif',
												},
											},
											grid: {
												display: false,
												drawBorder: false,
											},
											afterFit: (scale) => {
												scale.width = 114;
											},
										},
									},
									interaction: {
										axis: 'x',
										mode: 'nearest',
										intersect: false,
									},
									onHover: createChartHoverHandler,
								},
								plugins: [ verticalYAxisBorder, createChartMouseOutHandler ],
							};

							// create statsChart instance
							statsChart = new Chart(chartEl, statsChartConfig);
						});

						// get package versions data and create hits chart
						http.fetchPackageVersionStats(type, name, period).then((data) => {
							if (!data.total) {
								this.set('noVersionsData', true);
								return;
							}

							let array = [];

							Object.keys(data.versions).forEach((key) => {
								array.push({
									version: key,
									hits: data.versions[key].total,
									dates: data.versions[key].dates,
								});
							});

							let topFiveVersions = array.sort((a, b) => b.hits - a.hits).slice(0, 5);

							let maxValue = Math.max(...topFiveVersions.map(version => Math.max(...Object.values(version.dates))));
							let magnitude = Math.floor(Math.log10(maxValue));
							this.set('hitsChartYMax', Math.ceil(maxValue / Math.pow(10, magnitude)) * Math.pow(10, magnitude));

							this.animate('versionsHitsTotal', data.total);
							this.animate('topFiveVersions', topFiveVersions);

							// Maybe we have no stats yet.
							if (array[0]) {
								this.set('fileStatsVersion', array[0].version);
							}

							if (hitsChart) {
								hitsChart.destroy();
								hitsChart = null;
							}

							let chartEl = this.find('#hits-chart');

							// get range of y-axis
							let yAxisTicksAmount = 8;
							let yAxisRange = _.linRange(this.get('hitsChartYMax'), yAxisTicksAmount).reverse();

							// setup hitsChart datasets
							let datasets = topFiveVersions.reduce((datasets, tfvItem, idx) => {
								let dataset = {
									label: `v${tfvItem.version}`,
									data: Object.values(tfvItem.dates),
								};

								switch (idx) {
									case 0:
										dataset.borderColor = '#5C667A';
										dataset.backgroundColor = '#5C667A';
										break;
									case 1:
										dataset.borderColor = '#BC5090';
										dataset.backgroundColor = '#BC5090';
										break;
									case 2:
										dataset.borderColor = '#FFA600';
										dataset.backgroundColor = '#FFA600';
										break;
									case 3:
										dataset.borderColor = '#FF6361';
										dataset.backgroundColor = '#FF6361';
										break;
									case 4:
										dataset.borderColor = '#69C4F7';
										dataset.backgroundColor = '#69C4F7';
										break;
								}

								datasets.push(dataset);

								return datasets;
							}, []);

							// create external tooltip
							let externalTooltip = (ctx) => {
								let { chart, tooltip: tooltipModel } = ctx;

								let tooltipInstance = document.getElementById('hitsChart-tooltip');

								// Create element on first render
								if (!tooltipInstance) {
									tooltipInstance = document.createElement('div');
									tooltipInstance.id = 'hitsChart-tooltip';
									tooltipInstance.classList.add('tooltipEl');
									let wrapper = document.createElement('div');
									wrapper.classList.add('tooltipWrapper');
									tooltipInstance.appendChild(wrapper);
									let verticalLine = document.createElement('div');
									verticalLine.classList.add('tooltipVerticalLine');
									tooltipInstance.appendChild(verticalLine);
									chart.canvas.parentNode.appendChild(tooltipInstance);
								}

								// Hide if no tooltip
								if (tooltipModel.opacity === 0) {
									tooltipInstance.style.opacity = 0;
									return;
								}

								if (tooltipModel.body) {
									// get title text and body lines
									let titleText = new Date(tooltipModel.title[0].split(',')[0]).toLocaleDateString('en-US', { day: 'numeric', month: 'long', year: 'numeric' });
									let bodyLines = tooltipModel.body.map(item => item.lines[0]);

									// create title element
									let innerHtml = `<div class='tooltipTitle'>${titleText}</div><div class='tooltipBody'>`;

									// create body lines
									bodyLines.forEach((line, lineIdx) => {
										let coloredSquare = `<span class='tooltipSquare' style='background: ${tooltipModel.labelColors[lineIdx].backgroundColor}'></span>`;
										innerHtml += `<div class='tooltipBodyItem'>${coloredSquare}`;

										line.split(' ').forEach((part, partIdx) => {
											let prepPart = part;

											if (partIdx === 0) {
												prepPart = prepPart.replace(':', '');
											}

											innerHtml += `<span>${prepPart}</span>`;
										});

										innerHtml += '</div>';
									});

									let tooltipWrapper = tooltipInstance.querySelector('div.tooltipWrapper');
									tooltipWrapper.innerHTML = innerHtml;
								}

								tooltipInstance.style.opacity = 1;
								let { canvas: { offsetLeft }, chartArea } = chart;

								let tooltipVerticalLine = tooltipInstance.querySelector('.tooltipVerticalLine');

								// caretX min 0 max 1110
								// 120px based on the half width of the tooltip + vertical line and gap
								if (tooltipModel.caretX > 882) {
									tooltipVerticalLine.style.left = '228px';
									tooltipInstance.style.left = -120 + offsetLeft + tooltipModel.caretX + 'px';
								} else {
									tooltipVerticalLine.style.left = '-8px';
									tooltipInstance.style.left = 120 + offsetLeft + tooltipModel.caretX + 'px';
								}

								tooltipVerticalLine.style.height = chartArea.height + 'px';
								tooltipInstance.style.top = chartArea.top + 'px';
							};

							// create vertical y-axis border line
							let verticalYAxisBorder = {
								id: 'hitsChartYBorder',
								beforeDraw (chart) {
									let { ctx } = chart;
									ctx.save();
									ctx.beginPath();
									ctx.moveTo(89, 0);
									ctx.lineTo(89, 297);
									ctx.lineWidth = 1;
									ctx.strokeStyle = '#DADDE2';
									ctx.stroke();
									ctx.restore();
								},
							};

							// get period for chart representation
							let chartPeriod = this.get('statsPeriods')[this.get('statsPeriod')];

							// hitsChart configuration
							let hitsChartConfig = {
								type: 'line',
								data: {
									labels: _.getChartXAxisData(Object.keys(topFiveVersions[0].dates), chartPeriod),
									datasets,
								},
								options: {
									responsive: true,
									maintainAspectRatio: false,
									elements: {
										point: {
											pointRadius: 0,
											pointHoverRadius: 0,
										},
									},
									plugins: {
										legend: {
											display: false,
										},
										tooltip: {
											enabled: false,
											external: externalTooltip,
										},
									},
									scales: {
										x: {
											display: true,
											ticks: {
												color: '#5C667A',
												font: {
													size: 12,
													family: 'Lexend, sans-serif',
													lineHeight: 2,
												},
												// whole callback needed to prepare dates for displaying on the x-axis
												// since we need only the day and not full date (which we must to pass here for the tooltip title)
												callback (tickIdx) {
													let labelValue = this.getLabelForValue(tickIdx);
													// check if it is not contains only a date but also a month
													let day = Array.isArray(labelValue) ? labelValue[0].split('-').slice(-1)[0] : labelValue.split('-').slice(-1)[0];

													if (chartPeriod === 'year') {
														if (tickIdx !== 0 && tickIdx % 30 === 0) {
															return [ labelValue[1] ];
														}

														return;
													}

													if (Array.isArray(labelValue)) {
														return [ day, labelValue[1] ];
													}

													return [ day ];
												},
											},
											grid: {
												display: false,
												drawBorder: false,
											},
										},
										y: {
											display: true,
											min: yAxisRange[yAxisTicksAmount - 1],
											max: yAxisRange[0],
											ticks: {
												stepSize: yAxisRange[yAxisTicksAmount - 1],
												count: yAxisTicksAmount,
												color: '#5C667A',
												crossAlign: 'far',
												font: {
													size: 12,
													family: 'Lexend, sans-serif',
												},
											},
											grid: {
												drawBorder: false,
												color: '#CFD6DD',
												tickLength: 0,
											},
											afterFit: (scale) => {
												scale.width = 114;
											},
										},
									},
									interaction: {
										axis: 'x',
										mode: 'nearest',
										intersect: false,
									},
								},
								plugins: [ verticalYAxisBorder ],
							};

							// create hitsChart instance
							hitsChart = new Chart(chartEl, hitsChartConfig);
						});
					}
				});

				this.observe('package', () => {
					let readme = this.get('package').readme;
					let errMsg = this.get('algoliaReadmeErrMsg');

					if (!readme || readme === errMsg) {
						this.set('navRoute', 'stats');
					}
				});

				if (!this.get('versionP')) {
					this.set('versionP', this.get('package.version'));
				}
			}
		},
		onrender () {
			let resize = debounce(() => {
				this.add('_resizeId');
			});

			this.on('unrender', () => $(window).off('resize', resize));
			$(window).on('resize', resize);
			resize();
		},
	};
</script>
